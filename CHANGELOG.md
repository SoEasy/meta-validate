# 2.2.0
- модификатор `.with` теперь умеет принимать не только массив, но и набор строк
- немного переделано внутреннее устройство регистрации валидаторов
- возможность регистрировать свои классы с декораторами
- валидация запускается вне текущего eventLoop, пока примитивно
```
@MetaValidate.Register
class CustomValidators extends MVBase {
    private fooValidator(value?: any, instance?: any): boolean {
        return false;
    }

    foo(): CustomValidators {
        this.attachValidator('foo', this.fooValidator);
        return this;
    }
}

class ValueObject {
    ...
    @MetaValidate.Get<CustomValidators>(CustomValidators).foo().make()
    n: string;
}
```

# 2.1.5
- Указание кастомного имени для полей работает корректно во вложенных объектах и не вызывает ошибок

# 2.1.4
- Поправлен баг с валидатором regex

# 2.1.3
- Поправлена обязательность кастомного имени

# 2.1.2
- Добавлена возможность задать кастомное название для поля в объекте ошибок
```
@MetaValidate.String('customName')
```

# 2.1.1
- Поправлен баг с условием запуска валидации. Если объект уже был валидирован, то после срабатывания skip ошибки не исчезали, оставались старые

# 2.1.0
- Новое хранилище для ошибок, избавился от бага с пересечением ошибок разных экземпляров
- Изменена логика валидатора maxLength

# 2.0.8
- with работает на Nested поля

# 2.0.7
- skip работает на Nested поля

# 1.0.8
- Починен баг в вызове созависимых валидаторов

# 1.0.7
- В метод isFullValid можно передавать массив игнорируемых ключей

# 1.0.6
- Добавлен декоратор ValidateNested, который будет присоединяться к аггрегированному объекту, если тот имеет обсервабл validity
- Принята договоренность, что валидаторы возвращают true в случае, если есть ошибка
- Для разработки сделал папку sample

# 1.0.5
Интерфейс ReceiveValidity теперь заставляет класс иметь поле validity: Subject<Validity>, куда будет валиться объект с ошибками
