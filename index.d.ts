// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../rxjs

import { Subject } from 'rxjs';

export const VALIDATE_FIELDS_KEY = "MetaValidateFields";
export interface IBaseDecoratorType {
        required: () => IBaseDecoratorType;
        with: (fields: Array<string> | string, ...anotherFields: Array<string>) => IBaseDecoratorType;
        skipIf: (condition: (instance: any) => boolean) => IBaseDecoratorType;
        skip: (condition: (instance: any) => boolean) => IBaseDecoratorType;
        validators: Record<string, MVValidator>;
}
/**
    * @description Тип для описания валидности полей класса T.
    */
export interface MVValidity {
        [key: string]: MVFieldValidity | MVValidity;
}
export interface MVFieldValidity {
        [key: string]: boolean;
}
/**
    * @description Тип функции-валидатора
    */
export type MVValidator<ValueType = any, InstanceType = any> = (value: ValueType, instance?: InstanceType) => boolean;
/**
    * @description Интерфейс, который по хорошему должен реализовать класс, принимающий ошибки
    */
export interface ReceiveValidity {
        /**
            * @description Обсервер, в который будут валиться ошибки
            */
        validity$: Subject<Validity>;
}

/**
  * @description Хранилище данных о валидности полей с вспомогательным методом проверки на полную валидность
  */
export class Validity {
    errors: MVValidity;
    isFullValid(ignoreFields?: Array<string>): boolean;
}

export class MetaValidate {
    static Number<T>(customName?: string): MVNumber<T>;
    static String<T>(customName?: string): MVString<T>;
    static Trigger(): MVBase;
    static Nested(customName?: string): MVBase;
    static Base(customName?: string): MVBase;
    static Register<T extends MVBase>(validatorsClass: new () => T): void;
    static Get<T extends MVBase>(validatorClass: new () => T): T;
}

export type MVNumberArg<T> = number | ((instance: T) => number);
export class MVNumber<T> extends MVBase implements IBaseDecoratorType {
    required(): MVNumber<T>;
    skipIf(condition: (i: any) => boolean): MVNumber<T>;
    skip(condition: (i: T) => boolean): MVNumber<T>;
    with(fields: Array<string> | string, ...anotherFields: Array<string>): MVNumber<T>;
    custom(name: string, validator: (value: number, instance: any) => boolean): MVNumber<T>;
    min(arg: MVNumberArg<T>): MVNumber<T>;
    greater(arg: MVNumberArg<T>): MVNumber<T>;
    max(arg: MVNumberArg<T>): MVNumber<T>;
    less(arg: MVNumberArg<T>): MVNumber<T>;
    integer(): MVNumber<T>;
    negative(): MVNumber<T>;
    positive(): MVNumber<T>;
    divideBy(arg: MVNumberArg<T>): MVNumber<T>;
}

export type MVStringArg<ArgType, InstanceType> = ArgType | ((instance: InstanceType) => ArgType);
export class MVString<T> extends MVBase implements IBaseDecoratorType {
        required(): MVString<T>;
        skipIf(condition: (i: any) => boolean): MVString<T>;
        skip(condition: (i: T) => boolean): MVString<T>;
        with(fields: Array<string> | string, ...anotherFields: Array<string>): MVString<T>;
        custom(name: string, validator: (value: string, instance: any) => boolean): MVString<T>;
        convert(): MVString<T>;
        minLength(arg: MVStringArg<number, T>): MVString<T>;
        maxLength(arg: MVStringArg<number, T>): MVString<T>;
        length(arg: MVStringArg<number, T>): MVString<T>;
        regex(pattern: MVStringArg<RegExp, T>, name: string): MVString<T>;
        /**
            * @description Allow only a-z A-Z 0-9
            */
        alphanum(): MVString<T>;
        /**
            * @description Allow only a-z A-Z 0-9 - _
            */
        token(): MVString<T>;
}

export class MVBase implements IBaseDecoratorType {
    customErrorKey: string;
    protected attachedValidators: Record<string, MVValidator>;
    protected lastValidator: string;
    validateWith: Array<string>;
    skipCondition: (i: any) => boolean;
    validatorConditions: Record<string, (i: any) => boolean>;
    protected converters: Array<(value: any) => any>;
    isTrigger: boolean;
    isNested: boolean;
    constructor(customErrorKey?: string);
    attachValidator(name: string, validator: (v: any, i?: any) => boolean): void;
    required(): MVBase;
    skipIf(condition: (i: any) => boolean): MVBase;
    skip(condition: (i: any) => boolean): MVBase;
    with(fields: Array<string> | string, ...anotherFields: Array<string>): MVBase;
    custom(name: string, validator: (value: any, instance: any) => boolean): MVBase;
    readonly validators: Record<string, MVValidator>;
    make(): any;
}

