// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../rxjs

import { Subject } from 'rxjs';

export const VALIDATE_FIELDS_KEY = "JsonNameValidateFields";
export interface IBaseDecoratorType {
        required: () => IBaseDecoratorType;
        with: (fields: Array<string>) => IBaseDecoratorType;
        if: (condition: (instance: any) => boolean) => IBaseDecoratorType;
        skip: (condition: (instance: any) => boolean) => IBaseDecoratorType;
        validators: Record<string, MVValidator>;
}
/**
    * @description Тип для описания валидности полей класса T.
    */
export interface MVValidity {
        [key: string]: MVFieldValidity | MVValidity;
}
export interface MVFieldValidity {
        [key: string]: boolean;
}
/**
    * @description Тип функции-валидатора
    */
export type MVValidator<ValueType = any, InstanceType = any> = (value: ValueType, instance?: InstanceType) => boolean;
/**
    * @description Интерфейс, который по хорошему должен реализовать класс, принимающий ошибки
    */
export interface ReceiveValidity {
        /**
            * @description Обсервер, в который будут валиться ошибки
            */
        validity$: Subject<Validity>;
}

/**
  * @description Хранилище данных о валидности полей с вспомогательным методом проверки на полную валидность
  */
export class Validity {
    errors: MVValidity;
    isFullValid(ignoreFields?: Array<string>): boolean;
}

export class MetaValidate {
    static Number<T>(): MVNumber<T>;
    static String<T>(): MVString<T>;
    static Trigger(): any;
    static Nested(): any;
}

export type MVNumberArg<T> = number | ((instance: T) => number);
export class MVNumber<T> extends MVBase implements IBaseDecoratorType {
    required(): MVNumber<T>;
    if(condition: (i: any) => boolean): MVNumber<T>;
    skip(condition: (i: T) => boolean): MVNumber<T>;
    with(fields: Array<string>): MVNumber<T>;
    convert(): MVNumber<T>;
    min(arg: MVNumberArg<T>): MVNumber<T>;
    greater(arg: MVNumberArg<T>): MVNumber<T>;
    max(arg: MVNumberArg<T>): MVNumber<T>;
    less(arg: MVNumberArg<T>): MVNumber<T>;
    integer(): MVNumber<T>;
    negative(): MVNumber<T>;
    positive(): MVNumber<T>;
    divideBy(arg: MVNumberArg<T>): MVNumber<T>;
}

export type MVStringArg<ArgType, InstanceType> = ArgType | ((instance: InstanceType) => ArgType);
export class MVString<T> extends MVBase implements IBaseDecoratorType {
        required(): MVString<T>;
        if(condition: (i: any) => boolean): MVString<T>;
        skip(condition: (i: T) => boolean): MVString<T>;
        with(fields: Array<string>): MVString<T>;
        convert(): MVString<T>;
        minLength(arg: MVStringArg<number, T>): MVString<T>;
        maxLength(arg: MVStringArg<number, T>): MVString<T>;
        length(arg: MVStringArg<number, T>): MVString<T>;
        regex(pattern: MVStringArg<RegExp, T>, name: string): MVString<T>;
        /**
            * @description Allow only a-z A-Z 0-9
            */
        alphanum(): MVString<T>;
        /**
            * @description Allow only a-z A-Z 0-9 - _
            */
        token(): MVString<T>;
}

export class MVBase implements IBaseDecoratorType {
    protected prebuiltValidators: Record<string, MVValidator>;
    lastValidator: string;
    validateWith: Array<string>;
    skipCondition: (i: any) => boolean;
    validatorConditions: Record<string, (i: any) => boolean>;
    converters: Array<(value: any) => any>;
    isTrigger: boolean;
    isNested: boolean;
    required(): MVBase;
    if(condition: (i: any) => boolean): MVBase;
    skip(condition: (i: any) => boolean): MVBase;
    with(fields: Array<string>): MVBase;
    readonly validators: Record<string, MVValidator>;
    make(): any;
}

